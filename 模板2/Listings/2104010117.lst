C51 COMPILER V9.54   2104010117                                                            04/07/2023 20:45:48 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE 2104010117
OBJECT MODULE PLACED IN .\Objects\2104010117.obj
COMPILER INVOKED BY: F:\kile 5\C51\BIN\C51.EXE 2104010117.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\lib) DEBUG OBJECTEXTEND PR
                    -INT(.\Listings\2104010117.lst) TABS(2) OBJECT(.\Objects\2104010117.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include "onewire.h"
   3          #include "iic.h"
   4          #include "ds1302.h"
   5          
   6          #define YY P2=(P2&0x1f)
   7          #define Y4 YY|0x80
   8          #define Y5 YY|0xa0
   9          #define Y6 YY|0xc0
  10          #define Y7 YY|0xe0
  11          
  12          typedef unsigned char u8;
  13          typedef unsigned int  u16;
  14          
  15          #define SYS P0=0x00;Y5;YY;P0=0xff;Y4;YY;
  16          
  17          u8  EPR[]={150};
  18          u8  LED_V=0xff,Time10ms,num;
  19          u16 Time1s;
  20          
  21          //                                                                 9   10   11a 12b  13c   14d  15e  16f
  22          code u8 LED_duan[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0x88,0x83,0xc6,0xa1,0x86,0x8e,
  23                              0xc0&0x7f,0xf9&0x7f,0xa4&0x7f,0xb0&0x7f,0x99&0x7f,0x92&0x7f,0x82&0x7f,0xf8&0x7f,0x80&0x7f,0x90&0
             -x7f};
  24          u8 LED_buff[]={10,10,10,10,10,10,10,10};
  25          
  26          void LED(){P0=LED_V;Y4;YY;}
  27          
  28          void Timer0Init(void) 
  29          {
  30   1        AUXR |= 0x80;
  31   1        TMOD &= 0xF0;
  32   1        TMOD |= 0x04;
  33   1        TL0 = 0x00; 
  34   1        TH0 = 0x00; 
  35   1        TF0 = 0;    
  36   1        TR0 = 1;    
  37   1      }
  38          
  39          void Timer1Init(void) 
  40          {
  41   1        AUXR |= 0x40; 
  42   1        TMOD &= 0x0F;
  43   1        TL1 = 0x20;   
  44   1        TH1 = 0xD1;   
  45   1        TF1 = 0;  
  46   1        TR1 = 1;  
  47   1        EA=1;
  48   1        ET1=1;
  49   1      }
  50          
  51          
  52          
  53          void LED_Display()
C51 COMPILER V9.54   2104010117                                                            04/07/2023 20:45:48 PAGE 2   

  54          {
  55   1        static u8 i;
  56   1        P0=0xff;Y7;YY;
  57   1        P0=0x01<<i;Y6;YY;
  58   1        P0=LED_duan[LED_buff[i]];Y7;YY;
  59   1        if(++i==8)i=0;
  60   1      }
  61          
  62          void LED_Disbuff(u8 d1,d2,d3,d4,d5,d6,d7,d8)
  63          {
  64   1        LED_buff[0]=d1;
  65   1        LED_buff[1]=d2;
  66   1        LED_buff[2]=d3;
  67   1        LED_buff[3]=d4;
  68   1        LED_buff[4]=d5;
  69   1        LED_buff[5]=d6;
  70   1        LED_buff[6]=d7;
  71   1        LED_buff[7]=d8;
  72   1      }
  73          
  74          u16 WD;
  75          void DS18B20_R()
  76          {
  77   1        u8  L,H;
  78   1        u16 temp;
  79   1        init_ds18b20();
  80   1        Write_DS18B20(0xcc);
  81   1        Write_DS18B20(0x44);
  82   1         
  83   1        Delay_OneWire(200);
  84   1        
  85   1        init_ds18b20();
  86   1        Write_DS18B20(0xcc);
  87   1        Write_DS18B20(0xbe);
  88   1        
  89   1        L=Read_DS18B20();
  90   1        H=Read_DS18B20();
  91   1        
  92   1        temp=(H&0x0f)<<8;
  93   1        temp|=L;
  94   1        
  95   1        WD=temp*0.625;
  96   1      }
  97          
  98          u16 ADC,ADCR;
  99          void ADC_R(u8 chennl)
 100          {
 101   1        I2CStart();
 102   1        I2CSendByte(0x90);
 103   1        I2CWaitAck();
 104   1        
 105   1        I2CSendByte(chennl);
 106   1        I2CWaitAck();
 107   1        
 108   1        I2CStart();
 109   1        I2CSendByte(0x91);
 110   1        I2CWaitAck();
 111   1      
 112   1        ADCR=I2CReceiveByte();
 113   1        I2CSendAck(1);
 114   1        I2CStop();
 115   1        
C51 COMPILER V9.54   2104010117                                                            04/07/2023 20:45:48 PAGE 3   

 116   1        ADC=ADCR*500.0/255;
 117   1      }
 118          
 119          u8 DAC;
 120          void DAC_W(u8 dat)
 121          {
 122   1        I2CStart();
 123   1        I2CSendByte(0x90);
 124   1        I2CWaitAck();
 125   1        
 126   1        I2CSendByte(0x40);
 127   1        I2CWaitAck();
 128   1        
 129   1        I2CSendByte(dat);
 130   1        I2CWaitAck();
 131   1        I2CStop();
 132   1        
 133   1        DAC=dat/255.0*500;
 134   1      }
 135          
 136          u8 EEPRM;
 137          void EEPROM_R(u8 addr,u8* dat,u8 len)
 138          {
 139   1        I2CStart();
 140   1        I2CSendByte(0xa0);
 141   1        I2CWaitAck();
 142   1        
 143   1        I2CSendByte(addr);
 144   1        I2CWaitAck();
 145   1        
 146   1        I2CStart();
 147   1        I2CSendByte(0xa1);
 148   1        I2CWaitAck();
 149   1        while(len--)
 150   1        {
 151   2          *dat++=I2CReceiveByte();
 152   2          if(len)I2CSendAck(0);
 153   2          else   I2CSendAck(1);
 154   2        }
 155   1        I2CStop();
 156   1      
 157   1      }
 158          
 159          void EEPROM_W(u8 addr,u8* dat,u8 len)
 160          {
 161   1        
 162   1        I2CStart();
 163   1        I2CSendByte(0xa0);
 164   1        I2CWaitAck();
 165   1        
 166   1        I2CSendByte(addr);
 167   1        I2CWaitAck();
 168   1        while(len--)
 169   1        {
 170   2          I2CSendByte(*dat++);
 171   2          I2CWaitAck();
 172   2          I2C_Delay(200);
 173   2        }
 174   1        I2CStop();
 175   1      }
 176          
 177          u8 RTC_R[7]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};
C51 COMPILER V9.54   2104010117                                                            04/07/2023 20:45:48 PAGE 4   

 178          u8 RTC_W[8]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e};
 179          int RTC_HC[]={50,59,23,30,11,6,23};
 180          
 181          void DS1302_R()
 182          {
 183   1        u8 temp,i;
 184   1        for(i=0;i<7;i++)
 185   1        {
 186   2          temp=Read_Ds1302_Byte(RTC_R[i]);
 187   2          RTC_HC[i]=temp/16*10+temp%16;   
 188   2        }
 189   1      }
 190          
 191          void DS1302_W()
 192          {
 193   1        u8 i;
 194   1        Write_Ds1302_Byte(RTC_W[7],0x00);
 195   1        for(i=0;i<7;i++)
 196   1        {
 197   2          Write_Ds1302_Byte(RTC_W[i],RTC_HC[i]/10*16+RTC_HC[i]%10);
 198   2        }
 199   1        Write_Ds1302_Byte(RTC_W[7],0x80);
 200   1      }
 201          
 202          //u8 key_steta,key_value;
 203          //void key_scan()
 204          //{
 205          //  P3=0x0f;
 206          //  if(~P3&0x0f)
 207          //  {
 208          //    if(key_steta<255)key_steta++;
 209          //    if(P30==0)key_value=7;
 210          //    if(P31==0)key_value=6;
 211          //    if(P32==0)key_value=5;
 212          //    if(P33==0)key_value=4;
 213          //  }
 214          //  else
 215          //  {
 216          //    key_value=0;
 217          //    key_steta=0;
 218          //  }
 219          //}
 220          
 221          u8 key_steta,key_value,x,y;
 222          u8 key_values[4][4]=
 223          {
 224            7,11,15,19,
 225            6,10,14,18,
 226            5,9,13,17,
 227            4,8,12,16
 228          };
 229          void key_scan()
 230          {
 231   1        P3=0x0f;
 232   1        P4=0x00;
 233   1        if(~P3&0x0f)
 234   1        {
 235   2          if(key_steta<255)key_steta++;
 236   2          if(P30==0)x=0;
 237   2          if(P31==0)x=1;
 238   2          if(P32==0)x=2;
 239   2          if(P33==0)x=3;
C51 COMPILER V9.54   2104010117                                                            04/07/2023 20:45:48 PAGE 5   

 240   2          
 241   2          P3=0xf0;
 242   2          P4=0xff;
 243   2          
 244   2          if(P44==0)y=0;
 245   2          if(P42==0)y=1;
 246   2          if(P35==0)y=2;
 247   2          if(P34==0)y=3;
 248   2          key_value=key_values[x][y];
 249   2        }
 250   1        else
 251   1        {
 252   2          key_value=0;
 253   2          key_steta=0;
 254   2        }
 255   1      }
 256          
 257          void key_dispose()
 258          {
 259   1        key_scan();
 260   1        if(key_value==4&&key_steta==2)
 261   1        {
 262   2          num++;
 263   2        } 
 264   1      }
 265          
 266          
 267          
 268          void main()
 269          {
 270   1        SYS;
 271   1        Timer0Init();
 272   1        Timer1Init();
 273   1        DAC_W(102);
 274   1        DS1302_W();
 275   1      //  EEPROM_W(0x00,EPR,1);
 276   1        while(1)
 277   1        {
 278   2          
 279   2      //  if(Time1s%500==0)DS18B20_R();
 280   2      //  if(Time1s%200==0)ADC_R(0x43);
 281   2      //  if(Time1s%20==0)EEPROM_R(0x00,EPR,1);
 282   2      //  LED_Disbuff(1,10,10,10,10,WD/100,WD%100/10+17,WD%10);
 283   2      //  LED_Disbuff(1,10,10,10,10,ADC/100+17,ADC%100/10,ADC%10);
 284   2      //  LED_Disbuff(1,10,10,10,10,DAC/100+17,DAC%100/10,DAC%10);
 285   2      //  LED_Disbuff(1,10,10,10,10,EPR[0]/100,EPR[0]%100/10,EPR[0]%10);
 286   2      //    if(Time1s%800==0)DS1302_R();
 287   2      //    LED_Disbuff(RTC_HC[2]/10,RTC_HC[2]%10,10,RTC_HC[1]/10,RTC_HC[1]%10,10,RTC_HC[0]/10,RTC_HC[0]%10);
 288   2          LED_Disbuff(num,10,10,10,10,10,10,10);
 289   2          
 290   2        }
 291   1      }
 292          
 293          
 294          
 295          
 296          void Time1_interrupt() interrupt 3
 297          {
 298   1        ++Time10ms;
 299   1        ++Time1s;
 300   1        if(Time10ms==10){key_dispose();Time10ms=0;}
 301   1        if(Time1s==1000){Time1s=0;}
C51 COMPILER V9.54   2104010117                                                            04/07/2023 20:45:48 PAGE 6   

 302   1        LED_Display();
 303   1        
 304   1        
 305   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    932    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     72      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
