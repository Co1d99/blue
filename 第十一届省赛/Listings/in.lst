C51 COMPILER V9.54   IN                                                                    04/01/2023 16:59:44 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE IN
OBJECT MODULE PLACED IN .\Objects\in.obj
COMPILER INVOKED BY: F:\kile 5\C51\BIN\C51.EXE in.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\lib) DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\in.lst) TABS(2) OBJECT(.\Objects\in.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #define __REG52_H__
   3          #include "iic.h"
   4          #define YY P2=(P2&0x1f)
   5          #define Y4 YY|0x80
   6          #define Y5 YY|0xa0
   7          #define Y6 YY|0xc0
   8          #define Y7 YY|0xe0
   9          
  10          typedef unsigned char u8;
  11          typedef unsigned int  u16;
  12          
  13          #define SYS P0=0x00;Y5;YY;P0=0xff;Y4;YY;
  14          
  15          u8 LED_flag;
  16          u16 Time10ms,Time5s;
  17          
  18          //                                                                     11   12-u p    n
  19          code u8 LED_duan[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xff,0xc1,0x8c,0xc8,
  20                              0xC0&0x7f,0xF9&0x7f,0xA4&0x7f,0xB0&0x7f,0x99&0x7f,0x92&0x7f,0x82&0x7f,0xF8&0x7f,0x80&0x7f,0x90&0
             -x7f};
  21          u8 LED_buff[]={10,10,10,10,10,10,10,10};
  22          
  23          void Timer1_Init(void)
  24          {
  25   1        AUXR |= 0x40;
  26   1        TMOD &= 0x0F;
  27   1        TL1 = 0x20;   
  28   1        TH1 = 0xD1;   
  29   1        TF1 = 0;      
  30   1        TR1 = 1;
  31   1        EA=1;
  32   1        ET1=1;
  33   1      }
  34          //-----------------------------数码管----------------------------------
  35          void LED_display()
  36          {
  37   1        static u8 i=0;
  38   1        P0=0xff;Y7;YY;
  39   1        P0=0x01<<i;Y6;YY;
  40   1        P0=LED_duan[LED_buff[i]];Y7;YY;
  41   1        if(++i==8)i=0;
  42   1      }
  43          
  44          void LED_displaybuff(u8 d1,d2,d3,d4,d5,d6,d7,d8)
  45          {
  46   1        LED_buff[0]=d1;
  47   1        LED_buff[1]=d2;
  48   1        LED_buff[2]=d3;
  49   1        LED_buff[3]=d4;
  50   1        LED_buff[4]=d5;
  51   1        LED_buff[5]=d6;
  52   1        LED_buff[6]=d7;
  53   1        LED_buff[7]=d8;
C51 COMPILER V9.54   IN                                                                    04/01/2023 16:59:44 PAGE 2   

  54   1      }
  55          u8 LED_V=0xff;
  56          void LED()
  57          {
  58   1          P0=LED_V;Y4;YY;
  59   1      }
  60          
  61          
  62          
  63          //------------------------------ADC转换----------------------------------
  64          u8 ADC,Time_ADC,ADC_flag;
  65          u16 temp_ADC;
  66          void ADC_R(u8 channl)
  67          {
  68   1        IIC_Start();
  69   1        IIC_SendByte(0x90);
  70   1        IIC_WaitAck();
  71   1          
  72   1        IIC_SendByte(channl);
  73   1        IIC_WaitAck();
  74   1          
  75   1        IIC_Start();
  76   1        IIC_SendByte(0x91);
  77   1        IIC_WaitAck();
  78   1      
  79   1        ADC=IIC_RecByte();
  80   1        IIC_SendAck(1);
  81   1        IIC_Stop();
  82   1        
  83   1      }
  84          
  85          //-------------------------------AT24C02初始化-------------------------
  86          
  87          u8 EEPORM_R(u8 addr)
  88          {
  89   1        u8 dat;
  90   1        IIC_Start();
  91   1        IIC_SendByte(0xa0);
  92   1        IIC_WaitAck();
  93   1        IIC_SendByte(addr);
  94   1        IIC_WaitAck();
  95   1          
  96   1        IIC_Start();
  97   1        IIC_SendByte(0xa1);
  98   1        IIC_WaitAck();
  99   1        dat=IIC_RecByte();
 100   1        IIC_SendAck(1);
 101   1        IIC_Stop();
 102   1        
 103   1        return dat;
 104   1      }
 105          
 106          void EEPORM_W(u8 addr,u8 dat)
 107          {
 108   1        IIC_Start();
 109   1        IIC_SendByte(0xa0);
 110   1        IIC_WaitAck();
 111   1        IIC_SendByte(addr);
 112   1        IIC_WaitAck();
 113   1        IIC_SendByte(dat);
 114   1        IIC_WaitAck();
 115   1        IIC_Stop();
C51 COMPILER V9.54   IN                                                                    04/01/2023 16:59:44 PAGE 3   

 116   1        
 117   1      }
 118          //---------------------------------------矩阵按键----------------------------------------
 119          u8 key_values[4][4]=
 120          {
 121            7,11,15,19,
 122            6,10,14,18,
 123            5,9,13,17,
 124            4,8,12,16 
 125          };
 126          u8 key_state,key_value,x,y;
 127          void key_scan()
 128          {
 129   1        P3=0x0f;
 130   1        P4=0x00;
 131   1        if(~P3&0x0f)
 132   1        {
 133   2          if(key_state<255)key_state++;
 134   2          
 135   2          if(P30==0)x=0;
 136   2          if(P31==0)x=1;
 137   2          if(P32==0)x=2;
 138   2          if(P33==0)x=3;
 139   2          
 140   2          P3=0xf0;
 141   2          P4=0xff;
 142   2          if(P44==0)y=0;
 143   2          if(P42==0)y=1;
 144   2          if(P35==0)y=2;
 145   2          if(P34==0)y=3;
 146   2          
 147   2          key_value=key_values[x][y];
 148   2        }
 149   1        else
 150   1        {
 151   2          key_state=0;
 152   2          key_value=0;
 153   2        }
 154   1      }
 155          //---------------------------------------按键处理---------------------------------------
 156          u8  key_flag=0,ADC_CS_flag,key_num,key_17,ADC_JS_flag,num;
 157          u16 ADC_CS;
 158          void key_dispose()
 159          {
 160   1        if(Time10ms==10)
 161   1          {
 162   2            key_scan();
 163   2            Time10ms=0;
 164   2            if(key_value==12&&key_state==2)
 165   2            {
 166   3              if(++key_flag>2){key_flag=0;}
 167   3            
 168   3            }
 169   2            else if(key_value==16&&key_state==2&&ADC_CS_flag==1)
 170   2            {
 171   3              if(ADC_CS>=500){ADC_CS=0;}else{ADC_CS+=50;}
 172   3              EEPORM_W(0x00,ADC_CS/10);
 173   3            }
 174   2            else if(key_value==17&&key_state==2&&ADC_CS_flag==1)
 175   2            {
 176   3              if(ADC_CS<=0){ADC_CS=500;}else{ADC_CS-=50;}
 177   3              EEPORM_W(0x00,ADC_CS/10);
C51 COMPILER V9.54   IN                                                                    04/01/2023 16:59:44 PAGE 4   

 178   3            }else if(key_value==13&&key_state==2&&ADC_JS_flag==1)
 179   2            {
 180   3              num=0;
 181   3            }
 182   2          }
 183   1      }
 184          
 185          //---------------------------------------计数器---------------------------------------
 186          u8 t;
 187          void ADC_num()
 188          {
 189   1        switch(t)
 190   1        {
 191   2          case 0:
 192   2          if(temp_ADC>ADC_CS)
 193   2          {
 194   3            t=1;
 195   3          }
 196   2          
 197   2          break;
 198   2          case 1:
 199   2        if(temp_ADC<ADC_CS)
 200   2          {
 201   3            t=0;
 202   3            num++;
 203   3          }
 204   2          break;
 205   2        } 
 206   1      }
 207          //--------------------------------------LED显示---------------------------------------
 208          void LED_XS()
 209          {
 210   1        if(temp_ADC<ADC_CS)
 211   1        {
 212   2          ++Time5s;
 213   2          if(Time5s>5000)
 214   2          {
 215   3            LED_flag=1;
 216   3          }
 217   2        }
 218   1        else
 219   1        {
 220   2          LED_flag=0;Time5s=0;
 221   2        }
 222   1        
 223   1            
 224   1      }
 225          //-----------------------------------界面切换----------------------------------
 226          void JM_QH()
 227          {
 228   1          switch(key_flag)
 229   1          {
 230   2            case 0:
 231   2              ADC_JS_flag=0;
 232   2              ADC_CS_flag=0;
 233   2              LED_displaybuff(11,10,10,10,10,(temp_ADC/100)+14,temp_ADC%100/10,temp_ADC%10);
 234   2            break;
 235   2            case 1:
 236   2              ADC_JS_flag=0;
 237   2              ADC_CS_flag=1;
 238   2              LED_displaybuff(12,10,10,10,10,(ADC_CS/100)+14,ADC_CS%100/10,ADC_CS%10);
 239   2            break;
C51 COMPILER V9.54   IN                                                                    04/01/2023 16:59:44 PAGE 5   

 240   2            case 2:
 241   2              ADC_CS_flag=0;
 242   2              ADC_JS_flag=1;
 243   2              LED_displaybuff(13,10,10,10,10,10,num/10,num%10);
 244   2            break;
 245   2          }
 246   1      }
 247          
 248          
 249          
 250          //-------------------------------------主函数------------------------------------------
 251          
 252          void main()
 253          {
 254   1        SYS;
 255   1        Timer1_Init();
 256   1        ADC_CS=EEPORM_R(0x00)*10;
 257   1        while(1)
 258   1        {
 259   2          
 260   2          if(ADC_flag==1){ADC_R(0x03);temp_ADC=ADC*(500.0/255);EA=1;ADC_flag=0;}
 261   2          key_dispose();
 262   2          JM_QH();
 263   2          ADC_num();
 264   2          if(LED_flag==1){LED_V&=0xfe;}else{LED_V|=0xff;}
 265   2          if((num%2)!=0){LED_V&=0xfd;}else{LED_V|=0x02;}
 266   2        }
 267   1      }
 268          
 269          //------------------------------------定时器1中断--------------------------------------
 270          void Time1_interrupt() interrupt 3
 271          {
 272   1        Time10ms++;
 273   1        if(Time10ms%5==0){LED();}
 274   1        LED_XS();
 275   1        if(++Time_ADC==10){ADC_flag=1;EA=0;}
 276   1        LED_display();
 277   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1087    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
